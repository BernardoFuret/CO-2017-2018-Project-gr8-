#include <string>
#include <vector>
#include "targets/type_checker.h"
#include "targets/function_size_counter.h"
#include "ast/all.h"  // automatically generated

#define ASSERT_UNSPEC \
    { if (node->type() != nullptr && \
          node->type()->name() != basic_type::TYPE_UNSPEC) return; }

#define COUNT_FUNCTION_SIZE \
    gr8::function_size_counter __function_size_counter( _compiler ); \
    (node)->accept( &__function_size_counter, 0 );
    //std::cout << "!! function size is: " << __function_size_counter.counter() << std::endl;


//---------------------------------------------------------------------------
//------------GENERATED BY MK-VISITOR-SKEL.pl--------------------------------

void gr8::type_checker::do_sweeping_from_to_by_do_node(gr8::sweeping_from_to_by_do_node *const node, int lvl) {
  // Visit the lvalue:
  node->lvalue()->accept( this, lvl + 2 );

  // Visit the increment path values:
  node->from_expression()->accept( this, lvl + 2 );
  node->to_expression()->accept( this, lvl + 2 );
  node->by_expression()->accept( this, lvl + 2 );

  // They can't be strings:
  if (
    is_string( node->lvalue()->type() ) || is_string( node->from_expression()->type() ) 
    ||
    is_string( node->to_expression()->type() )  || is_string( node->by_expression()->type() ) 
  ) {
    throw std::string( "Strings cannot be used for sweeping!" );
  }
}

void gr8::type_checker::do_post_node(gr8::post_node *const node, int lvl) {
  // Visit:
  node->argument()->accept( this, lvl + 2 );
  
  // Pointers can't be printed:
  if ( is_pointer( node->argument()->type() ) ) {
    throw std::string( "Pointers cannot be posted!" );
  }
}
void gr8::type_checker::do_tweet_node(gr8::tweet_node *const node, int lvl) {
  // Visit:
  node->argument()->accept( this, lvl + 2 );

  // Pointers can't be printed:
  if ( is_pointer( node->argument()->type() ) ) {
    throw std::string( "Pointers cannot be tweeted!" );
  }
}

void gr8::type_checker::do_return_node(gr8::return_node *const node, int lvl) {
  // Check if it has a return value:
  if ( node->argument() != nullptr ) {
    // Visit:
    node->argument()->accept( this, lvl + 2 );
  }
}
void gr8::type_checker::do_stop_node(gr8::stop_node *const node, int lvl) {
  // IS EMPTY
  // CAN ONLY BE int BY THE SYNTAX
}
void gr8::type_checker::do_again_node(gr8::again_node *const node, int lvl) {
  // IS EMPTY
  // CAN ONLY BE int BY THE SYNTAX
}

void gr8::type_checker::do_input_node(gr8::input_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Can be multiple things, depending on what we are doing:
  node->type( new basic_type() );
}

void gr8::type_checker::do_plus_node(gr8::plus_node *const node, int lvl) {
  // It's a unary expression, so:
  processUnaryExpression( node, lvl + 2 );
}

void gr8::type_checker::do_objects_node(gr8::objects_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Visit:
  node->argument()->accept( this, lvl + 2 );
  
  // Check if it's a valid type: (int)
  if ( !is_int( node->argument()->type() ) ) {
    throw std::string( "Argument for 'objects' must be int!" );
  }

  // Set this node's type: (pointer)
  node->type( new basic_type( SIZE::_POINTER, basic_type::TYPE_POINTER ) );

  // Set this node's subtype: (anything)
  node->type()->_subtype = new basic_type();
}
void gr8::type_checker::do_address_node(gr8::address_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Visit:
  node->argument()->accept( this, lvl + 2 );

  // Set this node's type: (pointer)
  node->type( new basic_type( SIZE::_POINTER, basic_type::TYPE_POINTER ) );

  // Set this node's subtype: (whatever it was before, since we're getting its address)
  node->type()->_subtype = copy_type( node->argument()->type() );
}
void gr8::type_checker::do_cell_node(gr8::cell_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Visit the pointer:
  node->pointer()->accept( this, lvl + 2 );

  // Check if it's a valid type: (pointer)
  if ( !is_pointer( node->pointer()->type() ) ) {
    throw std::string( "Pointer argument for 'cell' must be a pointer!" );
  }
  
  // Visit the position:
  node->position()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int)
  if ( !is_int( node->position()->type() ) ) {
    throw std::string( "Position argument for 'cell' must be int!" );
  }

  // Set this node's type: (whatever was pointed by the pointer)
  node->type( copy_type( node->pointer()->type()->subtype() ) );
}

void gr8::type_checker::do_block_node(gr8::block_node *const node, int lvl) {
  // IS EMPTY
}

void gr8::type_checker::do_null_node(gr8::null_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Pointer to something:
  node->type( new basic_type( SIZE::_POINTER, basic_type::TYPE_POINTER ) );
  node->type()->_subtype = new basic_type(); // UNSPEC
}

void gr8::type_checker::do_variable_declaration_node(gr8::variable_declaration_node *const node, int lvl) {
  // Check if it has an intial value, to try to set the proper type for this node:
  if ( node->initially() != nullptr ) {
    // If the variable comes from another module, throw error:
    if ( node->isUse() ) {
      throw std::string( "External variables cannot be initialized!" );
    }

    // If it has an initial value, visit it too:
    node->initially()->accept( this, lvl + 2 );

    // Also check if the types match: (the node's type is always a valid type, due to syntax)
    basic_type *node_type  = node->type();
    basic_type *value_type = node->initially()->type();
    // The value type is unsepcified:
    if ( is_unspec( value_type ) ) {
      // Set the value type to the var type:
      node->initially()->type( copy_type( node_type ) );
    }
    // The var type and value types are different:
    else if ( !type_equals( node_type, value_type ) ) {
      // But maybe we can cast an int to a double:
      if ( is_double( node_type ) && is_int( value_type ) ) {
        // Set the initial value type as double:
        node->initially()->type( new basic_type( SIZE::_DOUBLE, basic_type::TYPE_DOUBLE ) );
      } 
      // They can still be compatible somehow:
      else if ( compatible_types( node_type, value_type ) ) {
        // Here, they are not equal; they are not double (node) and int (value).
        // Then they are compatible pointers:
        // Set the initial value type as this node's type:
        node->initially()->type( copy_type( node_type ) );
      }
      // They aren't compatible:
      else {
        throw std::string( "Types in variable declaration are not compatible!" );
      }
    }
    // Else, they both aren't unspecified nor not compatible. Aka; they are the same:
    else {
      // Nothing to do. They bot have the correct type. 
    }
  }

  // Create the symbol:
  std::shared_ptr<gr8::symbol> symbol = std::make_shared<gr8::symbol>(
    copy_type( node->type() ), node->name(), node->isPublic(), node->isUse()
  );
  
  // Try to insert it: (true => success; false => already exists in the current context)
  if ( !_symtab.insert( node->name(), symbol ) ) {
    // Variable exists:
    throw std::string( "Attempt to redeclare variable with name: '" + node->name() + "'!" );
  }
}

void gr8::type_checker::do_function_declaration_node(gr8::function_declaration_node *const node, int lvl) {
  // (allow: multiple declarations, as long as they are exactly equal.)
  // (disallow: declaring over variables.)

  // Save this node name to be used here on the output errors:
  std::string function_name = node->name();

  // Manipulate function name for RTS: ('covfefe' -> '_main')
  if ( node->name() == "covfefe" ) {
    node->set_as_main();
  }

  // Search for a possible symbol for this function:
  std::shared_ptr<gr8::symbol> symbol = _symtab.find( node->name() );

  // Check if it exists:
  if ( symbol ) {

    // It does, so we need to check if it is indeed a function:
    if ( !symbol->is_callable() ) {
      throw std::string( "Attempt to declare '" + function_name + "' as a function, but it was already declared as a variable!" );
    }

    // Then, check if the function was already defined: C allows this!
    //if ( symbol->is_defined() ) {
    //  throw std::string( "Attempt to declare '" + function_name + "', but it was already defined!" );
    //}

    // First, check for the function type:
    if ( !type_equals( symbol->type(), node->type() ) ) {
      throw std::string( "Attempt to declare previously declared function '" + function_name + "', but their type is different!" );
    }

    // Second, we need to check if the parameters match, between this declaration and previous ones:
    std::vector<basic_type*> previous_declaration_parameters_types = symbol->parameters();
    size_t number_of_previous_declaration_parameters_types = previous_declaration_parameters_types.size();
    cdk::sequence_node* this_declaration_parameters = node->parameters();
    // Check if both have the same size:
    if ( number_of_previous_declaration_parameters_types != this_declaration_parameters->size() ) {
      throw std::string( "Attempt to declare previously declared function '" + function_name + "', but the number of parameters is different!" );
    }
    // They do, so check if they all have the same types:
    for (size_t i = 0; i < number_of_previous_declaration_parameters_types; i++) {
      gr8::variable_declaration_node* variable_declaration = (gr8::variable_declaration_node*) node->parameters()->node( i ); // I know I will always have variable_declaration_nodes here, by yacc.
      if ( !type_equals( previous_declaration_parameters_types[ i ], variable_declaration->type() ) ) {
        throw std::string( "Attempt to redeclare previously declared function '" + function_name + "', but the types of the parameters are different!" );
      }
    }

  }

  // Else...
  // There's no symbol, so we need to create one:
  else {
    // Extract parameters' types: (copy) // TODO: Has to be the types, even though I really wanted the var nodes themselves... fix those too many errors if I have time.
    std::vector<basic_type*> parameters_types;
    size_t number_of_parameters = node->parameters()->size();
    for ( size_t i = 0; i < number_of_parameters; i++ ) {
      gr8::variable_declaration_node* variable_declaration = (gr8::variable_declaration_node*) node->parameters()->node( i ); // I know I will always have variable_declaration_nodes here, by yacc.
      parameters_types.push_back( copy_type( variable_declaration->type() ) );
    }

    // Create the symbol:
    symbol = std::make_shared<gr8::symbol>(
      copy_type( node->type() ), node->name(), node->isPublic(), false, parameters_types, -1
    );

    // Insert it in the symbol table:
    _symtab.insert( node->name(), symbol );
  }
}
// ----
void gr8::type_checker::do_function_definition_node(gr8::function_definition_node *const node, int lvl) {
  // (allow: defining previuosly declared functions.)
  // (disallow: redefining; defining a function with the same name as a declred one that has a different sig (in gr8) or return type.)

  // Save this node name to be used here on the output errors:
  std::string function_name = node->name();

  // Manipulate function name for RTS: ('covfefe' -> '_main'):
  if ( function_name == "covfefe" ) {
    node->set_as_main();
  }

  // Try to get the symbol:
  std::shared_ptr<gr8::symbol> symbol = _symtab.find( node->name() );

  // Check if it exists:
  if ( symbol ) {

    // It does, so we need to check if it is a function:
    if ( !symbol->is_callable() ) {
      throw std::string( "Attempt to define '" + function_name + "' as a function, but it was not callable!" );
    }

    // It is indeed a function, we need to see if it was already defined or was simply declared:
    else if ( symbol->is_defined() ) {
      throw std::string( "Attempt to redefine function '" + function_name + "'!" );
    }

    // Else, we are all good; the symbol exists in the table, but it's just as a declared function.
    // So then we need to compare this definition with the declaration, to see if they match.

    // First, check for the function type:
    if ( !type_equals( symbol->type(), node->type() ) ) {
      throw std::string( "Attempt to define previously declared function '" + function_name + "', but their type is different!" );
    }

    // Second, we need to check if the parameters match, between this definition and the declaration:
    std::vector<basic_type*> declaration_parameters_types = symbol->parameters();
    size_t number_of_declaration_parameters_types = declaration_parameters_types.size();
    cdk::sequence_node* definition_parameters = node->parameters();
    // Check if both have the same size:
    if ( number_of_declaration_parameters_types != definition_parameters->size() ) {
      throw std::string( "Attempt to define previously declared function '" + function_name + "', but the number of parameters is different!" );
    }
    // They do, so check if they all have the same types:
    for (size_t i = 0; i < number_of_declaration_parameters_types; i++) {
      gr8::variable_declaration_node* variable_declaration = (gr8::variable_declaration_node*) node->parameters()->node( i ); // I know I will always have variable_declaration_nodes here, by yacc.
      if ( !type_equals( declaration_parameters_types[ i ], variable_declaration->type() ) ) {
        throw std::string( "Attempt to define previously declared function '" + function_name + "', but the types of the parameters are different!" );
      }
    }

    // If we are here, it's all good. The symbol (function) will now be defined:
    symbol->defined();

    // Set the function size:
    COUNT_FUNCTION_SIZE;
    symbol->size( __function_size_counter.counter() );

    // Update the symbol table with it:
    //_symtab.replace_local( symbol->name(), symbol );
  }

  // Else...
  // There's no symbol, so we need to create one:
  else {
    // Extract parameters' types: (copy)
    std::vector<basic_type*> parameters_types;
    size_t number_of_parameters = node->parameters()->size();
    for ( size_t i = 0; i < number_of_parameters; i++ ) {
      gr8::variable_declaration_node* variable_declaration = (gr8::variable_declaration_node*) node->parameters()->node( i ); // I know I will always have variable_declaration_nodes here, by yacc.
      parameters_types.push_back( copy_type( variable_declaration->type() ) );
    }

    // Create the symbol and update our 'symbol' var:
    COUNT_FUNCTION_SIZE;
    symbol = std::make_shared<gr8::symbol>(
      copy_type( node->type() ), node->name(), node->isPublic(), true, parameters_types, __function_size_counter.counter()
    );

    // Insert it in the symbol table:
    _symtab.insert( node->name(), symbol );
  }
}
// ----
void gr8::type_checker::do_function_invocation_node(gr8::function_invocation_node *const node, int lvl) {
  ASSERT_UNSPEC;

  // Get the symbol:
  std::shared_ptr<gr8::symbol> symbol = _symtab.find( node->name() );

  // Check if this node's name exists: (if the symbol exists)
  if ( !symbol ) {
    throw std::string( "Attempt to call '" + node->name() + "', but it was not defined!" );
  }

  // Check if this symbol is a function:
  if ( !symbol->is_callable() ) {
    throw std::string( "Attempt to call '" + node->name() + "', but it was not a function!" );
  }

  // Check parameters' compatibility:
  size_t number_of_parameters = symbol->number_of_parameters(); //parameters().size();
  // Same number of parameters and args:
  if ( number_of_parameters != node->arguments()->size() ) {
    throw std::string( "Incorrect number of arguments for function '" + node->name() + "'!" );
  }

  // Iterate over the parameters to see if their type is compatible with the args':
  for ( size_t i = 0; i < number_of_parameters; i++ ) {

    basic_type *parameter_type     = symbol->parameters()[ i ];
    cdk::expression_node *argument = (cdk::expression_node*) node->arguments()->node( i ); // I know I will always have expression_nodes here, by yacc.

    // Visit the 'argument':
    argument->accept( this, lvl + 2 );

    // Compare them:
    if ( !compatible_types( parameter_type, argument->type() ) ) {

      // Not compatible:
      throw std::string( "Types of arguments for function '" + node->name() + "' are not compatible!" );

    } else {

      // If they are not equal:
      if ( !type_equals( parameter_type, argument->type() ) ) {
        // Then it's because the 'parameter_type' is double, but the 'argument' type is int: (because logic of compatible_types && !type_equals)
        argument->type( new basic_type( SIZE::_DOUBLE, basic_type::TYPE_DOUBLE ) ); // Cast.
      }

    }

  }

  // Finally, set this node's type: (whatever this function definition/declartion type is)
  node->type( copy_type( symbol->type() ) );
}


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void gr8::type_checker::do_sequence_node(cdk::sequence_node * const node, int lvl) {
  // CHECK
}

//---------------------------------------------------------------------------

void gr8::type_checker::do_nil_node(cdk::nil_node * const node, int lvl) {
  // CHECK
  // IS EMPTY
}
void gr8::type_checker::do_data_node(cdk::data_node * const node, int lvl) {
  // CHECK
  // IS EMPTY
}
void gr8::type_checker::do_double_node(cdk::double_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;
  node->type( new basic_type( SIZE::_DOUBLE, basic_type::TYPE_DOUBLE ) );
}
void gr8::type_checker::do_not_node(cdk::not_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit:
  node->argument()->accept( this, lvl + 2 );
  
  // Check if it's a valid type: (gr8 bool)
  if ( is_unspec( node->argument()->type() ) ) {
    // Unspecified, so convert to int:
    node->argument()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  } else if ( !is_int( node->argument()->type() ) ) {
    throw std::string( "Argument for 'not' must be int (bool)!" );
  }

  // Set this node's type: (int)
  node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
}

void gr8::type_checker::processBinaryExpression_and_or(cdk::binary_expression_node * const node, int lvl) {
  // Same functional code as modulus, but different concept (logical vs. arithmetic).
  ASSERT_UNSPEC;

  // Visit the left argument:
  node->left()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int)
  basic_type *left_type = node->left()->type();
  if ( is_unspec( left_type ) ) {
    // Unspecified, so convert to int:
    node->left()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  } else if ( !is_int( left_type ) ) {
    throw std::string( "Left argument for logical operation must be int!" );
  }

  // Visit the right argument:
  node->right()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int)
  basic_type *right_type = node->right()->type();
  if ( is_unspec( right_type ) ) {
    // Unspecified, so convert to int:
    node->right()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  } else if ( !is_int( right_type ) ) { 
    throw std::string( "Right argument for logical operation must be int!" );
  }

  // Set this node's type: (gr8 boolean)
  node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
}
void gr8::type_checker::do_and_node(cdk::and_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_and_or( node, lvl );
}
void gr8::type_checker::do_or_node(cdk::or_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_and_or( node, lvl );
}

//---------------------------------------------------------------------------

void gr8::type_checker::do_integer_node(cdk::integer_node * const node, int lvl) {
  ASSERT_UNSPEC;
  node->type(new basic_type(4, basic_type::TYPE_INT));
}

void gr8::type_checker::do_string_node(cdk::string_node * const node, int lvl) {
  ASSERT_UNSPEC;
  node->type(new basic_type(4, basic_type::TYPE_STRING));
}

//---------------------------------------------------------------------------

void gr8::type_checker::processUnaryExpression(cdk::unary_expression_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit:
  node->argument()->accept( this, lvl + 2 );

  // Check if it's a valid type: (must be either int or double)
  bool node_arg_type_is_int;
  if ( is_unspec( node->argument()->type() ) ) {
    // Unspecified, so convert to int:
    node->argument()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  } else if (
    !(node_arg_type_is_int = is_int( node->argument()->type() ))
    &&
    !is_double( node->argument()->type() )
  ) {
    throw std::string( "Argument for unary expression must be an int or a double!" );
  }

  // Set this node's type: (int or double)
  node->type(
    new basic_type(
      node_arg_type_is_int ? SIZE::_INT : SIZE::_DOUBLE,
      node_arg_type_is_int ? basic_type::TYPE_INT : basic_type::TYPE_DOUBLE
    )
  );
}

void gr8::type_checker::do_neg_node(cdk::neg_node * const node, int lvl) {
  // CHECK
  processUnaryExpression(node, lvl);
}

//---------------------------------------------------------------------------

void gr8::type_checker::processBinaryExpression(cdk::binary_expression_node * const node, int lvl) {
  // Just validates the left and right types.
  ASSERT_UNSPEC;

  // Visit the left argument:
  node->left()->accept( this, lvl + 2 );
  basic_type *left_type = node->left()->type();

  // Visit the right argument:
  node->right()->accept( this, lvl + 2 );
  basic_type *right_type = node->right()->type();

  // Check for unspec and adapt them:
  // (unspec && !unspec => l:=r)
  if ( !is_unspec( left_type ) && is_unspec( right_type ) ) {
    node->left()->type( copy_type( right_type ) );
    left_type = copy_type( right_type );
  }
  // (!unspec && unspec => r:=l)
  else if ( is_unspec( left_type ) && !is_unspec( right_type ) ) {
    node->right()->type( copy_type( left_type ) );
    right_type = copy_type( left_type );
  }
  // (unspec && unspec => r:=int ; l:=int)
  else if ( is_unspec( left_type ) && is_unspec( right_type ) ) {
    node->left ()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
    node->right()->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
    left_type  = new basic_type( SIZE::_INT, basic_type::TYPE_INT );
    right_type = new basic_type( SIZE::_INT, basic_type::TYPE_INT );
  }

  // Check if left is a valid type: (int, double or pointer)
  if ( !is_int( left_type ) && !is_double( left_type ) && !is_pointer( left_type ) ) {
    throw std::string( "Left argument for binary expression must be int, double or pointer!" );
  }

  // Check if right is a valid type: (int, double or pointer)
  if ( !is_int( right_type ) && !is_double( right_type ) && !is_pointer( right_type ) ) { 
    throw std::string( "Right argument for binary expression must be int, double or pointer!" );
  }
}
void gr8::type_checker::do_add_node(cdk::add_node * const node, int lvl) {
  // CHECK
  // Standard verification:
  processBinaryExpression(node, lvl);

  // Verifiy compatibilities and do conversions:
  basic_type *left_type = node->left()->type();
  basic_type *right_type = node->right()->type();
  // (int + int)
  if ( is_int( left_type ) && is_int( right_type ) ) {
    // Set this node's type: (int)
    node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  }
  // (int + double) || (double + int) || (double + double)
  else if (
    ( is_int( left_type ) && is_double( right_type ) )
    ||
    ( is_double( left_type ) && is_int( right_type ) )
    ||
    ( is_double( left_type ) && is_double( right_type ) )
  ) {
    // Set this node's type: (double)
    node->type( new basic_type( SIZE::_DOUBLE, basic_type::TYPE_DOUBLE ) ); 
  }
  // (int + pointer) || (pointer + int)
  else if (
    ( is_int( left_type ) && is_pointer( right_type ) )
    ||
    ( is_pointer( left_type ) && is_int( right_type ) )
  ) {
    // Set this node's type: (pointer, similar to the pointer argument)
    node->type(
      copy_type(
        is_pointer( left_type ) ? left_type : right_type
      )
    ); 
  }
  // No more options:
  else {
    throw std::string( "Invalid arguments' types for 'plus' binary expression!" );
  }
}
void gr8::type_checker::do_sub_node(cdk::sub_node * const node, int lvl) {
  // CHECK
  // Standard verification:
  processBinaryExpression(node, lvl);

  // Verifiy compatibilities and do conversions:
  basic_type *left_type = node->left()->type();
  basic_type *right_type = node->right()->type();
  // (int - int)
  if ( is_int( left_type ) && is_int( right_type ) ) {
    // Set this node's type: (int)
    node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
  }
  // (int - double) || (double - int) || (double - double)
  else if (
    ( is_int( left_type ) && is_double( right_type ) )
    ||
    ( is_double( left_type ) && is_int( right_type ) )
    ||
    ( is_double( left_type ) && is_double( right_type ) )
  ) {
    // Set this node's type: (double)
    node->type( new basic_type( SIZE::_DOUBLE, basic_type::TYPE_DOUBLE ) ); 
  }
  // (pointer - pointer)
  else if ( is_pointer( left_type ) && is_pointer( right_type ) && type_equals( left_type, right_type ) ) {
    // Set this node's type: (int (number of pointers in between))
    node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) ); 
  }
  // (pointer - int)
  else if ( is_pointer( left_type ) && is_int( right_type )) {
    // Set this node's type: (pointer)
    node->type( copy_type( left_type ) );
  }
  // No more options:
  else {
    throw std::string( "Invalid arguments' types for 'minus' binary expression!" );
  }
}

void gr8::type_checker::processBinaryExpression_mul_div( cdk::binary_expression_node * const node, int lvl ) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit the left argument:
  node->left()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int or double)
  basic_type *left_type = node->left()->type();
  bool left_type_is_double = is_double( left_type );
  if ( !is_int( left_type ) && !left_type_is_double ) {
    throw std::string( "Left argument for 'times' or 'over' binary expression must be int or double!" );
  }

  // Visit the right argument:
  node->right()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int or double)
  basic_type *right_type = node->right()->type();
  bool right_type_is_double = is_double( right_type );
  if ( !is_int( right_type ) && !right_type_is_double ) { 
    throw std::string( "Right argument for 'times' or 'over' binary expression must be int or double!" );
  }

  // Set this node's type:
  bool node_is_double = left_type_is_double || right_type_is_double;
  node->type(
    new basic_type(
      node_is_double ? SIZE::_DOUBLE : SIZE::_INT,
      node_is_double ? basic_type::TYPE_DOUBLE : basic_type::TYPE_INT
    )
  );
}
void gr8::type_checker::do_mul_node(cdk::mul_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_mul_div( node, lvl );
}
void gr8::type_checker::do_div_node(cdk::div_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_mul_div( node, lvl );
}
void gr8::type_checker::do_mod_node(cdk::mod_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit the left argument:
  node->left()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int)
  basic_type *left_type = node->left()->type();
  if ( !is_int( left_type ) ) {
    throw std::string( "Left argument for 'modulus' binary expression must be int!" );
  }

  // Visit the right argument:
  node->right()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int)
  basic_type *right_type = node->right()->type();
  if ( !is_int( right_type ) ) { 
    throw std::string( "Right argument for 'modulus' binary expression must be int!" );
  }

  // Set this node's type: (int)
  node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
}

void gr8::type_checker::processBinaryExpression_lt_gt( cdk::binary_expression_node * const node, int lvl ) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit the left argument:
  node->left()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int or double)
  basic_type *left_type = node->left()->type();
  if ( !is_int( left_type ) && !is_double( left_type ) ) {
    throw std::string( "Left argument for 'above' or 'below' binary expression must be int or double!" );
  }

  // Visit the right argument:
  node->right()->accept( this, lvl + 2 );

  // Check if it's a valid type: (int or double)
  basic_type *right_type = node->right()->type();
  if ( !is_int( right_type ) && !is_double( right_type ) ) {
    throw std::string( "Right argument for 'above' or 'below' binary expression must be int or double!" );
  }

  // Set this node's type: (gr8 boolean)
  node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
}
void gr8::type_checker::do_lt_node(cdk::lt_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_lt_gt( node, lvl );
}
void gr8::type_checker::do_le_node(cdk::le_node * const node, int lvl) {
  // CHECK
  // UNUSED
}
void gr8::type_checker::do_ge_node(cdk::ge_node * const node, int lvl) {
  // CHECK
  // UNUSED
}
void gr8::type_checker::do_gt_node(cdk::gt_node * const node, int lvl) {
  // CHECK
  processBinaryExpression_lt_gt( node, lvl );
}


void gr8::type_checker::do_ne_node(cdk::ne_node * const node, int lvl) {
  // CHECK
  // UNUSED
}
void gr8::type_checker::do_eq_node(cdk::eq_node * const node, int lvl) {
  ASSERT_UNSPEC;

  // Standard verification:
  processBinaryExpression(node, lvl);

  // Set this node's type: (gr8 boolean)
  node->type( new basic_type( SIZE::_INT, basic_type::TYPE_INT ) );
}

//---------------------------------------------------------------------------

void gr8::type_checker::do_identifier_node(cdk::identifier_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;
  const std::string &id = node->name();
  std::shared_ptr<gr8::symbol> symbol = _symtab.find(id);

  if (symbol != nullptr) {
    node->type(symbol->type());
  } else {
    throw id;
  }
}

void gr8::type_checker::do_rvalue_node(cdk::rvalue_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;
  try {
    node->lvalue()->accept(this, lvl);
    node->type( copy_type( node->lvalue()->type() ) );
  } catch (const std::string &id) {
    throw "undeclared variable '" + id + "'";
  }
}

void gr8::type_checker::do_assignment_node(cdk::assignment_node * const node, int lvl) {
  // CHECK
  ASSERT_UNSPEC;

  // Visit the left value:
  node->lvalue()->accept(this, lvl);

  // Visit the right value:
  node->rvalue()->accept(this, lvl + 2);

  // Types verification:
  basic_type *left_type  = node->lvalue()->type();
  basic_type *right_type = node->rvalue()->type();
  /*std::cout << std::endl;
  std::cout << "int: " << basic_type::TYPE_INT << std::endl;
  std::cout << "double: " << basic_type::TYPE_DOUBLE << std::endl;
  std::cout << "string: " << basic_type::TYPE_STRING << std::endl;
  std::cout << "pointer: " << basic_type::TYPE_POINTER << std::endl;
  std::cout << "r: " << right_type->name() << "\nl: " << left_type->name() << std::endl;
  std::cout << std::endl;*/

  // Check if they are a valid type:
  if ( /*is_void( left_type ) ||*/ is_void( right_type ) ) {
    throw std::string( "Types in assignment are not valid!" );
  }

  // Check if they are compatible: (same type or lvalue is double and rvalue is int)
  if ( !compatible_types( left_type, right_type ) ) {
    throw std::string( "Types in assignment are not compatible!" );
  }

  // Set this node's type: (whatever the left value type is)
  node->type(
    // Here, the left type has the correct type, except if it is a pointer pointing to unspec,
    // in which case we use the right value type:
    copy_type( points_to_unspec( left_type ) ? right_type : left_type )
  );
}

//---------------------------------------------------------------------------

void gr8::type_checker::do_evaluation_node(gr8::evaluation_node * const node, int lvl) {
  node->argument()->accept(this, lvl + 2);
}

/*void gr8::type_checker::do_print_node(gr8::print_node * const node, int lvl) {
  node->argument()->accept(this, lvl + 2);
}*/

//---------------------------------------------------------------------------

/*void gr8::type_checker::do_read_node(gr8::read_node * const node, int lvl) {
  try {
    node->argument()->accept(this, lvl);
  } catch (const std::string &id) {
    throw "undeclared variable '" + id + "'";
  }
}*/

//---------------------------------------------------------------------------

/*void gr8::type_checker::do_while_node(gr8::while_node * const node, int lvl) {
  node->condition()->accept(this, lvl + 4);
}*/

//---------------------------------------------------------------------------

void gr8::type_checker::do_if_node(gr8::if_node * const node, int lvl) {
  // CHECK
  node->condition()->accept(this, lvl + 4);
}

void gr8::type_checker::do_if_else_node(gr8::if_else_node * const node, int lvl) {
  // CHECK
  node->condition()->accept(this, lvl + 4);
}
